\chapter{Introdução}

A Web 2.0 descreve \textit{sites} da World Wide Web que enfatizam conteúdos gerados pelos próprios usuários, a usabilidade e experiência de usuário que esses conteúdos proporcionam e a interoperabilidade. O termo foi popularizado por Tim O'Reilly e Dale Dougherty no final de 2004 na conferência O'Reilly Media Web 2.0, porém o termo foi primeiramente citado e consequentemente inventado por Darcy DiNucci em 1999. Apesar da Web 2.0 sugerir uma nova versão da World Wide Web, não referencia nenhuma mudança na especificação técnica e sim mudanças acumuladas no modo de como as páginas web eram feitas e utilizadas \cite{graham2005}, \cite{oreilly2005}, \cite{strickland2007}, \cite{dinucci1999}.

	Anteriormente, desenvolver software era um esporte coletivo onde exigiam um time onde cada participante tinha um papel definido e específico de atuação. Esses papéis eram, entre outros, administrador de banco de dados e gerente de sistemas. Uma das mudanças ocorridas descritas pela Web 2.0 foi a redução de pessoal em um projeto. Uma mudança de cunho ágil reforçada pelo então aclamado Frederick Brooks, onde o mesmo ressaltava que designando mais programadores para um projeto que está atrasado em relação à sua agenda, fará-lo atrasar ainda mais. Isto se dá devido ao fato dos novos integrantes precisarem gastar uma determinada quantidade de tempo até que se tenha todo o conhecimento tácito dos antigos integrantes e durante esse tempo a comunicação entre os antigos e novos integrantes viria a consumir uma quantidade estritamente crescente de recursos, dos quais um deles é o tempo da própria equipe \cite{Brooks:1995:MM:207583}. Desta forma, os responsáveis pelo desenvolvimento do software queriam produzir pelo menos as mesmas quantidades desenvolvidas, porém com número de pessoas reduzido. Aparentemente impraticável a priori, esse problema foi resolvido aplicando, parcialmente ou em totalidade, as práticas ágeis e consequentemente fazendo milhares de programadores mudar os ambientes extremamente complexos e robustos, tais como os ambientes de ERP e Java Enterprise, para ambientes mais simples com arquiteturas e frameworks simplificados \cite{kent1998}.

	Um desses frameworks simplificados chama-se Ruby on Rails. Criado por David Heinemeier Hansson durante seu trabalho na empresa de aplicações web 37signals\footnote{https://37signals.com/}, para desenvolver uma ferramenta de gerenciamento de projeto chamada de Basecamp. Posteriormente a 37signals iria adotar o nome da sua ferramenta e se chamar Basecamp\footnote{https://basecamp.com/} \cite{grimmer2006}. Rails inclui ferramentas que transformam tarefas comuns da rotina de desenvolvimento em simples comandos, por exemplo, \textit{scaffolding} é um comando responsável por gerar toda a estrutura de um CRUD incluindo testes automatizados. Ele também inclui um simples servidor Ruby chamado WEBrick e um sistema de build chamado Rake. Uma outra característica marcante do Rails é a capacidade de integração com outras soluções ou pacotes chamados Gems. O \textit{framework} Rails ainda conta com  o ambiente o RubyGems, responsável por gerenciar as Gems e distribuí-las em um formato padrão facilitando a sua instalação e gerenciamento; e o Bundler responsável por gerenciar as dependências de sua aplicação dispondo as Gems do RubyGems em uma determinada versão com apenas uma linha de código.

Uma outra importante mudança teve inicio em 1997 quando Eric Raymond publicou uma análise reflexiva da comunidade hacker e de princípios de software livre. O livro The Cathedral and the Bazaar \cite{Raymond:2001:CBM:365399} recebeu atenção significante no começo de 1998 e foi um dos fatores motivantes para a corporação Netscape lançar um de seus mais populares sistemas, conhecido atualmente como Mozilla Firefox e Thunderbird, como software livre. Apesar de ter sofrido com algumas turbulências após seu surgimento, uma reinvenção no nome do movimento trouxe a presença de Linus Torvalds, Bruce Perens e Tim O'Reilly para o movimento que se passava a chamar Open Source Initiative\cite{osi2012}. Aliada a iniciativa de software livre criaram se vários sistemas para hospedagem de código e dentre eles o GitHub. O GitHub\footnote{https://github.com/} provê hospedagem de repositórios Git remotos e suporta operações e interações através de uma interface Web. Discussões são feitas através de comentários nos pedidos de atualização, chamados Pull Requests. GitHub ainda oferece integração com várias ferramentas que geralmente são utilizadas nos projetos de software, tais como Issue Tracker, Wiki e também servidores de integração contínua.

Por ter uma fácil acessibilidade e um processo de contribuição eficiente, projetos hospedados no GitHub são acessíveis para um grande número de colaboradores em potencial. Cada membro possui um perfil, pode seguir atividades de outros membros ou projetos e pode ver a lista de contatos de outros membros, caracterizando o GitHub como uma rede social de acordo com Boyd e Ellison\cite{2007:00393}. Ademais, os donos dos projetos e os membros do time contribuidor são facilmente contactados para potenciais contribuições externas e os usuários desses projetos ainda podem demonstrar o seu afeto pelo projeto sendo um stargazer[9].

No universo Rails, o uso das ferramentas citadas transforma o desenvolvimento de uma aplicação em um todo, mudando o processo de escrever todo o código para a procura de soluções ou fragmentos de soluções contidos em Gems, hospedadas em sua grande maioria no GitHub, e integrá-las. Porém ainda existem problemas nessa abordagem, pois com a massificação e enorme acessibilidade cedida pelo GitHub existem uma vastidão de soluções e a tarefa de encontrar a melhor solução ainda é uma tarefa árdua. Em poucas palavras, desenvolvedores tem acesso a todas as soluções, porém são muitas e a princípio é difícil definir qual delas é a mais adequada para o seu projeto e é pensando nisso que sites como o Ruby Toolbox foram criados. São sites que mostram as opções de soluções para um determinado problema classificado entre as categorias listadas e de alguma forma essas soluções possuem um índice calculado a partir de seus dados. Tomemos o site Ruby Toolbox\footnote{www.ruby-toolbox.com}, por exemplo, a popularidade de uma gem é determinada de duas formas distintas e de acordo com a localização dos dados utilizados para determinar o índice. Por exemplo, a popularidade do RubyGems é indicado pelo número de downloads de uma determinada gem e utilizando este princípio a gem mais popular é a Rake com quase 70 milhões de downloads. No caso do GitHub, a popularidade é a quantidade de seguidores e a quantidade de cópias independentes possuídos pelo repositório onde a gem está contida e a gem mais popular é o Rails com aproximadamente 26 mil seguidores e 10 mil cópias independentes. O cálculo para determinar a popularidade das outras gem é uma média entre a comparação desses indíces com as gems mais populares citadas.

Apesar de útil, essa abordagem apresenta algumas falhas. Uma dessas falhas, por exemplo decorre da acessibilidade e massificação do GitHub, pois para seguir ou fazer uma cópia independente de um repositório requer apenas ter uma conta e um clique em um dos dois botões para seguir ou copiar, podendo desta forma manipular os dados do índice e dar indicações erroneas. Além da massificação, ainda existe também o populismo de certas Gems em relação a outras por conta dos seus contribuidores, pois caso um contribuidor famoso faça uma requisição de atualização em uma determinada Gem, parte de sua popularidade é aderida àquela Gem fazendo pessoas familiares ou simpatizantes deste contribuidor incrementar o índice sem ao menos baixar ou utilizar a Gem. Isso não seria problema, se esses dados apenas indicassem a popularidade de um projeto, porém foi constatado através de um questionário, onde o publico alvo eram os desenvolvedores do GitHub, que esses índices servem como critério de desempate na escolha entre dois projetos. É notável que a popularidade de projetos afete outros projetos de maneira negativa como foi identificado por [11], principalmente no quesito de falta de contribuição. 

Dessa forma nossa abordagem visa facilitar a escolha entre soluções baseado em threads de discussões.